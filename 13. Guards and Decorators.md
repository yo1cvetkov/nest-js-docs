# Guards and Decorators in Nest

## Guards

**Guards** are one of the schematics of NestJS and their purpose is to approve or reject requests coming to the specific route.
When created, Guards can be used within controller classes or within controller methods.

Also Guards can be applied to the module or to the entire application.

### Guard example - AccessTokenGuard

To generate a guurad we use the `nest g gu` command and it will generate the guard file for us which contains starter code for the guard like this:

```typescript
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class AccessTokenGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}
```

Basically, every guard needs to implement this method. This method returns boolean in some kind (like a promis, observable or simple boolean value).

Since, we want to validate the token we will need some dependencies: `jwtService` and `jwtConfig`

```typescript
@Injectable()
export class AccessTokenGuard implements CanActivate {
  constructor(
    private readonly jwtService: JwtService,
    @Inject(jwtConfig.KEY)
    private readonly jwtConfiguration: ConfigType<typeof jwtConfig>
  ) {}

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}
```

We also have the `ExecutionContext` provided by the `canActivate` method which allows us to get the request. This execution context has multiple methods like `switchToHttp`, `switchToRpc` and so on because it is reusable and can be used inside different kinds of contexts (API types basically whether we are working with the REST API or RPC).

In order to grab the request we use the following chain of methods:

`const request = context.switchToHttp().getRequest()`

Now in order to extract the JWT from the header if it exists, we can define the `private` method for that:

```typescript
private extractJwt(request: Request): string | undefined {
  const [_, token] = request.headers.authorization?.split(' ') ?? [];

  return token;
}
```

Now after we check extract the token we can verify it using the `verifyAsync` from the `jwtService` and if token is verified, attach it on the `request.user`.

```typescript
try {
  const payload = await this.jwtService.verifyAsync(token, this.jwtConfiguration);

  request[REQUEST_USER_KEY] = payload;
} catch (error) {
  throw new UnauthorizedException("Token not valid");
}
```

This way we checked for the validity of the token and threw the error if the token is invalid.

### Appying the guard - endpoint and controller based

Now, to apply the guard to the specific endpoint of controller in this case we will need the JwtConfig together with the JwtService imported inside the module we want guard to apply for.

Next, we apply the guard for the single endpoint like this:

We use the `@UseGuards` decorator where we pass the `AccessTokenGuard` like this:

```typescript
@UseGuards(AccessTokenGuard)
@Post('create-many')
public createManyUsers(...) {
  ...
}
```

If we use this decorator before the `@Controller` decorator, we will apply it for the whole controller.

### Applying the guard - globally module or application based

The way we provide the Guard to the entire module is by passing the object to the `providers` array. This object should look something like this:

```typescript
@Module({
  ...
  providers: [
    ...,
    {
      provide: APP_GUARD,
      useClass: AccessTokenGuard
    }
  ]
})
```

This way, when we set the `provide` value to the `APP_GUARD` we protected the **whole application**. Now since this is App-wide guard we don't want it to be defined as the global guard inside the `users.module` or any other module than `app.module` so we need to import there neccessarry dependencies like jwtConfig and JwtModule and then we need to provide the app-wide guard.

This way jwtConfig doesn't need to be module scoped config anymore but we can leave it like this.

Now, since entire app is protected we will need some kind of decorator to tell the specific non-protected endpoints that they are public.

## Decorators
